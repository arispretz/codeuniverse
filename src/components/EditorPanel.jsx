/**
 * @fileoverview EditorPanel component.
 * Provides a Monaco-based code editor with linting, autocomplete, and execution capabilities.
 * Integrates backend services for code analysis, suggestions, and execution results.
 *
 * @module components/EditorPanel
 */

import React, { useEffect } from "react";
import { Box, Button, Paper } from "@mui/material";
import MonacoEditor from "@monaco-editor/react";
import * as monaco from "monaco-editor";

import {
  lintCodeService,
  runCodeService,
  autocompleteService,
} from "../services/editorService.js";

const languageMap = {
  javascript: 63,
  python: 71,
  cpp: 54,
  java: 62,
};

const EditorPanel = ({
  code,
  setCode,
  language,
  editorRef,
  showSnackbar,
  setExecutionResult,
}) => {
  const lintCode = async (code) => {
    try {
      const data = await lintCodeService(code, language);
      const markers = Array.isArray(data.messages)
        ? data.messages.map((msg) => ({
            startLineNumber: msg.line,
            startColumn: msg.column,
            endLineNumber: msg.endLine || msg.line,
            endColumn: msg.endColumn || msg.column + 1,
            message: msg.message,
            severity:
              msg.severity === "error"
                ? monaco.MarkerSeverity.Error
                : monaco.MarkerSeverity.Warning,
          }))
        : [];

      if (editorRef.current) {
        monaco.editor.setModelMarkers(
          editorRef.current.getModel(),
          "eslint",
          markers
        );
      }
    } catch (error) {
      console.error("‚ùå Error linting code:", error);
      showSnackbar("‚ùå Error analyzing code");
    }
  };

  const handleRunCode = async () => {
    const languageId = languageMap[language];
    try {
      const data = await runCodeService(code, languageId);
      const output = data.stdout || data.stderr || "No output";
      setExecutionResult(output);
    } catch (error) {
      setExecutionResult(`Execution error: ${error.message}`);
    }
  };

  const setupAutocomplete = (editor, monacoInstance) => {
    editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Space, async () => {
      const currentCode = editor.getValue();
      try {
        const data = await autocompleteService(currentCode, language);
        if (data.suggestion) {
          editor.executeEdits("", [
            {
              range: editor.getSelection(),
              text: data.suggestion,
              forceMoveMarkers: true,
            },
          ]);
          showSnackbar("‚ú® Autocomplete applied");
        }
      } catch (error) {
        console.error("‚ùå Error fetching autocomplete:", error);
      }
    });

    editor.onDidType(async (text) => {
      if (text === "." || text === "(") {
        try {
          const data = await autocompleteService(editor.getValue(), language);
          if (data.suggestion) {
            showSnackbar("üí° Suggestion: " + data.suggestion.slice(0, 60) + "...");
          }
        } catch (error) {
          console.error("‚ùå Error fetching autocomplete:", error);
        }
      }
    });

    monacoInstance.languages.registerCompletionItemProvider(language, {
      provideCompletionItems: async () => {
        try {
          const data = await autocompleteService(editor.getValue(), language);
          return {
            suggestions: [
              {
                label: "üí° AI Suggestion",
                kind: monacoInstance.languages.CompletionItemKind.Snippet,
                insertText: data.suggestion || "",
                documentation: "Generated by AI Assistant",
              },
            ],
          };
        } catch (error) {
          console.error("‚ùå Error fetching autocomplete suggestions:", error);
          return { suggestions: [] };
        }
      },
    });
  };

  useEffect(() => {
    const handleResize = () => {
      if (editorRef.current) {
        editorRef.current.layout();
      }
    };
    window.addEventListener("resize", handleResize);
    return () => window.removeEventListener("resize", handleResize);
  }, [editorRef]);

  return (
    <Paper elevation={3} sx={{ mt: 2, p: 2, height: "100%", display: "flex", flexDirection: "column" }}>
      <Box sx={{ flex: 1, minHeight: 400 }}>
        <MonacoEditor
          height="100%"
          width="100%"
          language={language}
          value={code}
          onChange={(value) => {
            setCode(value);
            if (["javascript", "python", "cpp", "java"].includes(language)) {
              lintCode(value);
            }
          }}
          onMount={(editor, monacoInstance) => {
            editorRef.current = editor;
            setupAutocomplete(editor, monacoInstance);
            editor.layout();
          }}
          options={{
            theme: "vs-dark",
            automaticLayout: true,
          }}
        />
      </Box>

      <Box textAlign="right" mt={2}>
        <Button variant="contained" onClick={handleRunCode}>
          ‚ñ∂Ô∏è Run Code
        </Button>
      </Box>
    </Paper>
  );
};

export default EditorPanel;
